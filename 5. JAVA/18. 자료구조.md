# 자료구조
## Collection
* `Collection<E>` (`java.util.Collection<E>`)은 ***인자의 나열을 가지는 자료구조에 대한 인터페이스***이다 **E 는 참조타입**이다
* 객체 메서드
    * **add(E e)** : 호출 대상의 인자로 e 를 추가한다
    * **addAll(Collection<? extends S> c)** : 호출 대상의 **인자로 c 가 가진 인자를 모두 추가**한다
    * **clear()** : 호출 대상이 가지고 있는 **인자를 모두 제거**한다
    * **contains(Object o)** : 호출 대상이 가지고 있는 인자들 중 **전달 받은 객체 o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 `참(true)인 인자가 있는가의 여부를 반환`한다**
    * **containsAll(Collection<?> c)** 호출 대상이, **전달 받은 c 가 가지는 모든 인자에 대해 동등(==)하거나 equals() `메서드 호출 결과가 참(true)인 인자들을 모두 가지고 있는가의 여부를 반환`한다**
    * **remove(Object o)** : 호출 대상이 가지고 있는 인자들 중 **전달받은 객체 `o 에 대해 동등(==)`하거나 equals() 메서드 `호출 결과가 참(true)인 인자를 제거`한다**
    * **removeAll(Collection<?> c)** : 호출 대상이 가지고 있는 인자들 중 **전달받은 `c 가 가지는 모든 인자에 대해 동등(==)`하거나 equals() 메서드 `호출 결과가 참(true)인 인자들 모두 제거`한다**
    * **size()** : 호출 대상이 가지고 있는 인자의 갯수를 반환한다 **(length를 사용하지 않는다)**
### List
* `List<E>`(`java.util.List<E>`) 인터페이스를 **상속 받고, 순서가 있는 인자의 나열을 가지는 자료 구조에 대한 인터페이스**이다
* 객체 메서드 <!--List는 Collection 의 객체 메서드들을 모두 가지고 있다-->
    * **add(int i, E e)** : **호출 대상의 인자로 e 를 추가**한다. 단, **추가하는 인자의 순번이 i 가 되도록** 한다. 기존에 **순번이 i 인 인자 및 후행하는 인자의 순번은 모두 1씩 뒤로 밀린다**
    * **get(int i)** : 호출 대상이 가지고 있는 인자 중 **순번이 i 인 인자를 반환**한다
    * **indexOf(Object o)** : 호출 대상이 가지고 있는 인자 중 **o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 첫번째 인자의 순번을 반환**한다. **그러한 인자가 `없다면 -1을 반환`한다**
    * **lastIndexOf(Object o)** : 호출 대상이 가지고 있는 인자 중 **o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 마지막 인자의 순번을 반환**한다. **그러한 인자가 `없다면 -1을 반환`한다**
    * **remove(int i)** : 호출 대상이 가지고 있는 인자 중 **순번이 i 인 인자를 `제거`한다. `후행하는 인자의 순번은 모두 1 씩 당겨진`다**
    * **set(int i, E e)** : 호출 대상이 가지고 있는 인자 중 **순번이 `i 인 인자의 값을 e 로 재할당`한다**
#### ArrayList
* `ArrayList<E>`(`java.util.ArrayList<E>`)**클래스는 `List<E>` 인터페이스를 구현하는 클래스**이다
* 각 인자를 일반 배열처럼 관리하기 때문에, 제공된 순번에 따른 **인자 접근이 매우 빠르지만**, 인자 제거 및 추가 등 **인자의 개수가 변하는 경우 속도가 매우 느리다**
* 즉, ***`추가 및 삭제가 적고 조회가 많다면 이를 사용한다`***
#### Vector
* `Vector<E>`(`java.util.Vector<E>`)클래스는 `List<E>` 인터페이스를 구현하는 클래스이다
* 역할과 작동 방식은 `ArrayList<E>` 와 동일하나 메서드가 동기화(Synchronized)되어있다는 차이가 있다
#### LinkedList
* `LinkedList<E>`(`java.util.LinkedList<E>`)클래스는 `List<E>` 인터페이스를 구현한다
* 각 인자의 존재를 `인접한 인자로 하여금 기억하게 함으로써 각 인자를 관리`한다. 이때문에 제공된 **순번에 따른 인자 접근은 느리지만** 인자 제거 및 추가 등 **인자의 개수가 변하는 경우는 속도가 빠르다**
* 즉, ***`추가 및 삭제가 많고 조회가 적다면 이를 사용한다`***
#### Stack
* `Stack<E>`(`java.util.Stack<E>`)클래스는 `Vector<E>` 클래스를 상속받는 자료구조 이다
* 후입선출(LIFO Last In First Out) 방식으로 인자를 관리한다
* 객체 메서드
    * **`push(E e)`** : 호출 대상의 **가장 위에 인자 e 를 추가**한다
    * **`pop()`** : 호출 대상이 가지고 있는 인자 중 **가장 위에 있는 인자를 제거하고 반환**한다
    * **`peek()`** : 호출 대상이 가지고 있는 인자 중 **가장 위에 있는 인자를 반환**한다
---------------------------------------------------------------------
### Set
* `Set<E>`인터페이스는 `Collection<E>` **인터페이스를 상속받고 `순서가 없는` 인자의 나열을 가지는 자료구조**이다
* 객체 메서드
    * iterator() : Set 객체가 가진 인자를 반복할 수 있는 반복자 `Iterator<E>` 객체를 반환한다
#### HashSet
* `HashSet<E>(java.util.HashSet<E>)`클래스는 **`Set<E>` 인터페이스를 구현하는 자료구조**이다
* 인자를 순서대로 보관하지않고 **인자인 객체의 해쉬 값(hashCode)을 기준으로 동일 여부를 판단하여 보관**한다
#### SortedSet
* `SortedSet<E>(java.util.SortedSet<E>)`인터페이스는 `Set<E>` 인터페이스를 상속 받는 인자 정렬을 위한 자료구조이다
#### TreeSet
* `TreeSet<E>(java.util.TreeSet<E>)` 클래스는 `SortedSet<E>` 인터페이스를 구현하는 자료구조이다.
- 인자를 정렬함에 있어 이진 탐색 트리(Binary Search Tree) 구조를 활용하여, 인자 검색과 정렬이 빠르다.
---------------------------------------------------------------------
## Map
* `Map<E>(java.util.Map<E>)`인터페이스는 **키와 값으로 이루어진 쌍들의 집합**을 가지는 자료구조이다
* 객체 메서드
    * `clear()`: 호출 대상이 **가지고 있는 쌍을 모두 제거**한다.
    * `containsKey(K k)`: 호출 대상이 가지고 있는 쌍 중 **키가 전달된 `k 와 같은 쌍이 있는가`의 여부**를 반환한다.
    * `containsValue(V v)`: 호출 대상이 가지고 있는 쌍 중 **값이 전달된 `v 와 같은 쌍이 있는가`의 여부**를 반환한다.
    * `get(K k)`: 호출 대상이 가지고 있는 쌍 중 **키가 전달된 `k 와 같은 쌍의 값`을 반환**한다.
    * `getOrDefault(K k, V v)`: 호출 대상이 가지고 있는 쌍 중 **키가 전달된 `k와 같은 쌍이 있다면 그 쌍의 값`을, `없다면 v`를 반환**한다.
    * `keySet()`: 호출 대상이 가지고 있는 **쌍의 키를 인자로 가지는 `Set<K>` 객체를 반환**한다.
    * `put(K k, V v)`: 호출 대상이 가지고 있는 **쌍 중 `k`와 동일한 키를 가지는 쌍이 없다면, 키로 `k`를, 값으로 `v`를 가지는 쌍을 추가**한다. 만약 **이미 `k`와 `동일한 키를 가지는 쌍이 있다면 해당 쌍의 값만 v 로 재할당`한다**
    * `putIfAbsent(K k, V v)`: 호출 대상이 ***가지고 있는 쌍 중 `k`와 동일한 키를 가지는 쌍이 없다면, 키로 `k`를, 값으로 `v`를 가지는 쌍을 추가***한다. 만약 **이미 `k`와 동일한 키를 가지는 쌍이 있다면 아무런 동작도 하지 않는다**
    * `remove(K k)`: 호출 대상이 **가지고 있는 쌍 중 키가 `k`와 같은 쌍을 제거**한다.
    * `replace(K k, V v)`: 호출 대상이 **가지고 있는 쌍 중 `k`와 동일한 키를 가지는 쌍이 있다면, 해당 쌍의 값만 `v`로 재할당**한다. **만약 `k`와 동일한 키를 가지는 쌍이 없다면 아무런 동작도 하지 않는다**
    * `size()`: 호출 대상이 가지고 있는 **쌍의 개수를 반환**한다.
    * `values()`: 호출 대상이 가지고 있는 **쌍들의 값을 인자로 가지는 `Collection<E>` 객체를 반환**한다.
* `Map<K, V>` 타입은 **동일한 키를 가지는 쌍을 `여러개 가질 수 없다`.**
### HashMap
* `HashMap<K, V>(java.util.HashMap<K, V>)` 클래스는 `Map<K, V>` **인터페이스를 구현하는 자료구조**이다
* 동일한 키를 가지는 **쌍이 있는가의 여부를 키 객체의 해쉬 값(hashCode)을 기준으로 검사**한다
### HashTable
* `HashTable<K, V>(java.util.Hashtable<K, V>)`클래스는 `Map<K, V>`인터페이스를 구현하는 자료구조이다
* **역할과 작동 방식은 `HashMap<K, V>`과 동일**하나, **메서드가 `동기화(Synchronized)되어 있다는 차이`가 있다**
### SortedMap
* `SortedMap<>(java.util.SortedMap<K, V>)`인터페이스는 `Map<K, V>` 인터페이스를 **상속 받는 쌍을 정렬하기 위한 자료 구조이다. 단, `정렬 기준은 키(K)` 이다**
#### TreeMap
* `TreeMap<>(java.util.TreeMap<K, V>)`클래스는 `SortedMap<K, V>`인터페이스를 구현하는 자료구조이다
* **쌍을 정렬함에 있어 `이진 탐색 트리 구조(Binary Search Tree)를 활용`하며, `검색과 정렬이 빠르다`.**
## 자료구조의 위치
### Collection 자료구조 위치
* `List부분의 자료구조`는 Collection >> List >> ArrayList ,Vector, LinkedList 가 있으며 Vector >> Stack 이 있다. **이 중 챙겨야할것은 `ArrayList`** 이다
* `Set부분의 자료구조`는 Collection >> Set >> HashSet,SortedSet 이 있고, SortedSet >> TreeSet 이 있다
### Map 자료구조 위치
* Map >> HashMap, Hashtable, SortedMap 이 있고 SortedMap >> TreeMap 이 있다 **이 중 챙겨야할것은 `HashMap`** 이다
* Collection 과는 개별이다