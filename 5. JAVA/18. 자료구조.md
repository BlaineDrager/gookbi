# 자료구조
## Collection
* `Collection<E>` (`java.util.Collection<E>`)은 ***인자의 나열을 가지는 자료구조에 대한 인터페이스***이다 **E 는 참조타입**이다
* 객체 메서드
    * **add(E e)** : 호출 대상의 인자로 e 를 추가한다
    * **addAll(Collection<? extends S> c)** : 호출 대상의 인자로 c 가 가진 인자를 모두 추가한다
    * **clear()** : 호출 대상이 가지고 있는 인자를 모두 제거한다
    * **contains(Object o)** : 호출 대상이 가지고 있는 인자들 중 전달 받은 객체 o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 인자가 있는가의 여부를 반환한다
    * **containsAll(Collection<?> c)** 호출 대상이, 전달 받은 c 가 가지는 모든 인자에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 인자들을 모두 가지고 있는가의 여부를 반환한다
    * **remove(Object o)** : 호출 대상이 가지고 있는 인자들 중 전달받은 객체 o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 인자를 제거한다
    * **removeAll(Collection<?> c)** : 호출 대상이 가지고 있는 인자들 중 전달받은  c 가 가지는 모든 인자에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 인자들 모두 제거한다
    * **size()** : 호출 대상이 가지고 있는 인자의 갯수를 반환한다 **(length를 사용하지 않는다)**
## List
* `List<E>`(`java.util.List<E>`) 인터페이스를  상속 받고, 순서가 있는 인자의 나열을 가지는 자료 구조에 대한 인터페이스이다
* 객체 메서드 <!--List는 Collection 의 객체 메서드들을 모두 가지고 있다-->
    * **add(int i, E e)** : 호출 대상의 인자로 e 를 추가한다. 단, 추가하는 인자의 순번이 i 가 되도록 한다. 기존에 순번이 i 인 인자 및 후행하는 인자의 순번은 모두 1씩 뒤로 밀린다
    * **get(int i)** : 호출 대상이 가지고 있는 인자 중 순번이 i 인 인자를 반환한다
    * **indexOf(Object o)** : 호출 대상이 가지고 있는 인자 중 o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 첫번째 인자의 순번을 반환한다. 그러한 인자가 없다면 -1을 반환한다
    * **lastIndexOf(Object o)** : 호출 대상이 가지고 있는 인자 중 o 에 대해 동등(==)하거나 equals() 메서드 호출 결과가 참(true)인 마지막 인자의 순번을 반환한다. 그러한 인자가 없다면 -1을 반환한다
    * **remove(int i)** : 호출 대상이 가지고 있는 인자 중 순번이 i 인 인자를 제거한다. 후행하는 인자의 순번은 모두 1 씩 당겨진다
    * **set(int i, E e)** : 호출 대상이 가지고 있는 인자 중 순번이 i 인 인자의 값을 e 로 재할당한다
### ArrayList
* `ArrayList<E>`(`java.util.ArrayList<E>`)클래스는 `List<E>` 인터페이스를 구현하는 클래스이다
* 각 인자를 일반 배열처럼 괄리하기 때문에, 제공된 순번에 따른 인자 접근이 매우 빠르지만, 인자 제거 및 추가 등 인자의 개수가 변하는 경우 속도가 매우 느리다
* 즉, 추가 및 삭제가 적고 조회가 많다면 이를 사용한다
### Vector
* `Vector<E>`(`java.util.Vector<E>`)클래스는 `List<E>` 인터페이스를 구현하는 클래스이다
* 역할과 작동 방식은 `ArrayList<E>` 와 동일하나 메서드가 동기화(Synchronized)되어있다는 차이가 있다
### LinkedList
* `LinkedList<E>`(`java.util.LinkedList<E>`)클래스는 `List<E>` 인터페이스를 구현한다
* 각 인자의 존재를 인접한 인자로 하여금 기억하게 함으로써 각 인자를 관리한다. 이때문에 제공된 순번에 따른 인자 접근은 느리지만 인자 제거 및 추가 등 인자의 개수가 변하는 경우는 속도가 빠르다
* 즉, 추가 및 삭제가 많고 조회가 적다면 이를 사용한다
### Stack
* `Stack<E>`(`java.util.Stack<E>`)클래스는 `Vector<E>` 클래스를 상속받는 자료구조 이다
* 후입선출(LIFO Last In First Out) 방식으로 인자를 관리한다
* 객체 메서드
    * push(E e) : 호출 대상의 가장 위에 인자 e 를 추가한다
    * pop() : 호출 대상이 가지고 있는 인자 중 가장 위에 있는 인자를 제거하고 반환한다
    * peek() : 호출 대상이 가지고 있는 인자 중 가장 위에 있는 인자를 반환한다
#### 자료구조의 위치
* Collection 아래 List 가 있고 List 아래 ArrayList ,Vector, LinkedList 가 있으며 Vector 아래에 Stack 이 있다 이 중 챙겨야할것은 ArrayList 이다