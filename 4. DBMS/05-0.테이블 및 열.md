# 테이블
* 테이블(Table)은 실제 데이터(레코드)를 담기 위해 존재한다
* 테이블은 반드시 스키마에 속해있어야 한다
* 명명법 : 스네이크 케이스, 복수형(~~s 같은 형)
## 생성하기
* 테이블을 생성하기 위해 아래 쿼리를 실행한다
>```sql
>CREATE TABLE `스키마 이름`.`테이블 이름`
>(
>   [열 구조,...]
>   [제약 조건 구조,...]
>);
>```
>* 위의 테이블은 쿼리가 한 개인 것이다 쿼리는 ;를 기준으로 만들어진다
>* 소속될 스키마는 반드시 존재하는 상태여야 한다.
>* 동일한 스키마 내에서 이미 사용 중인 테이블 이름을 사용할 수 없다.
>>* 예시
>>```sql
>>CREATE TABLE `korea`.`populations2` 
>>(
>>    `area_code` VARCHAR(4), 
>>    `value`     INT UNSIGNED,
>>    `as_of`     DATE
>>);
>>```
### 기본키 제약 조건 (Primary Key Constraint)
* 기본키가 되는 한 개 이상의 열(들)은 해당 테이블의 기준이 되는 열(들)을 의미한다
* 기본키로 지정된 열(들)이 가지는 값에 대해서 레코드들은 중복되는 값을 가질 수 없다
* 하나의 테이블은 기본키를 가지지 않거나 하나의 기본키만 가질 수 있다. 하나의 기본키가 여러개의 열을 가질 수 있지만 여러 개의 기본키가 존재할 수는 없다
* 기본키의 대상이되는 열은 NULL 을 허용할 수 없음으로 해당 열은 NOT NULL 이 필수 이다
* 기본키를 선언하려면 아래와 같이 제약 조건 구조를 작성한다
```sql
CONSTRAINT PRIMARY KEY ([`열 이름`,...]);
```
### 유니크 제약 조건 (Unique Key Constraint)
* 유니크로 지정된 열에는 해당하는 레코드가 가지는 값이 중복 될 수 없다
* **`값이 중복될 수 없다는 부분은 기본키와 같으나`**, 유니크는 테이블에서 ***대표성을 띄진 않는다***는 점과 하나의 테이블이 여러 개의 유니크를 가질 수 있다는 점이 다르다
* 추가로 기본키는 NULL 값을 허용하지 않지만, 유니크는 NULL 값이 허용되면, NULL 값에 대해서는 중복 검사를 하지 않는다
* 유니크 제약조건을 선언하려면 아래와 같이 제약조건 구조를 작성한다
```SQL
CONSTRAINT UNIQUE ([`열 이름`,...])
```
### 외래키 제약 조건 (Foreign Key Constraint)
* 외래키 제약 조건이 적용되는 열이 가지는 레코드의 값을 참조 대상인(Referencing) 테이블의 열이 가지는 레코드의 값으로 제한하기 위해 사용하는 제약조건이다
* 참조  대상이 되는 열은 ***기본키이거나 유니크***이어야 한다
* 외래키를 적용하고 있는 열과 참조 대상인 열의 데이터 타입이 같아야 한다
* 외래키를 선언하려면 아래와 같이 제약 조건 구조를 작성한다
>```sql
>CONSTRAINT FOREIGN KEY ([`열 이름`,...]) REFERENCES `참조 대상 스키마`.`참조 대상 테이블` ([`참조 대상 열 이름`,...]) 
>[ON DELETE CASCADE]? 
>[ON UPDATE CASCADE]?
>```
>* ON DELETE CASCADE : 참조 대상이 삭제되면 현재 레코드도 같이 삭제되게 한다
>* ON UPDATE CASCADE : 참조 대상이 수정되면 현재 레코드도 같이 수정되게 한다
>>* 보통 ON DELETE CASCADE 와 ON UPDATE CASCADE 는 함께 들어간다
### 체크 제약 조건 (Check Constraint)
* 체크 제약 조건은 주어진 조건을 만족할 때에만 레코드를 삽입할 수 있게 하기 위해 사용한다
* 다른 제약 조건과 달리 반드시 어떠한 열에 의존적이지는 않다
* 체크 제약조건을 선언하려면 아래와 같이 제약 조건 구조를 작성한다
```SQL
CONSTRAINT CHECK ([조건])
```
>* 각 키를 설정한 예시
>```SQL
>CREATE TABLE `world`.`countries2`
>(
>    `iso_code` VARCHAR(2) NOT NULL,
>    `name` VARCHAR(10) NOT NULL ,
>    `area` INT UNSIGNED NOT NULL,
>    CONSTRAINT PRIMARY KEY (`iso_code`), -- 해당 부분으로 기본키를 설정할 수 있다
>    CONSTRAINT UNIQUE (`name`) -- 유니크 키 설정부분
>    CONSTRAINT FOREIGN KEY (`name`) REFERENCES `world`.`contries`(`name`) -- 외래키 설정 부분으로 REFERENCES 를 통해 참조할 대상을 찾는 것이다 `world`.`contries` 에 있는 `name` 이 참조되는 대상이다
>    ON DELETE CASCADE -- ON DELETE CASCADE 를 통해 참조되는 부모가 삭제되는 것이 허용 되게 만들어 줌
>    ON UPDATE CASCADE -- ON UPDATE CASCADE 를 통해 참조되는 부모가 수정이 가능하게 만들어 줌
>);
>```
>* 각 키 설정을 할때에는 테이블을 만들 때 사용하면 된다 각 키들은 해당 열을 만들 때 뒷부분에 추가로 해도 되지만 알아 보기 쉽게 하기 위해 아래의 CONSTRAINT 를 활용해서 사용하는 편이다
## 조회하기
* 특정 스키마에 소속되어있는 테이블의 목록을 조회하기 위해 아래 쿼리를 실행한다
```SQL
SHOW  TABLES IN `스키마`;
```
* 특정 테이블이 가지고 있는 열의 구조를 조회하기 위해 아래 쿼리를 실행한다
```SQL
DESC `스키마`.`테이블`;

DESCRIBE `스키마`.`테이블`;
```
## 수정하기
### 이름 및 소속 스키마 변경하기
* 테이블의 이름을 변경하거나 소속된 스키마를 변경하고자 할 때 아래의 쿼리를 실행한다
* 스키마의 이름을 변경하는 것은 불가능함으로 새로운 이름을 가지는 스키마를 생성하고, 이전 스키마에 있던 모든 테이블을 신규 스키마에 옮긴뒤 기존 스키마를 삭제하는 형식으로 진행한다
>```SQL
>ALTER TABLE : `기존 스키마`.`기존 테이블` RENAME `새로운 스키마`.`새로운 테이블`;
>```
>* 소속 스키마 변경 없이 테이블 이름만 변경하고자 한다면, **기존 스키마**와 **새로운 스키마**를 동힐하게 유지하면 된다 
>* 테이블 이름 변경 없이 소속 스키마만 변경하고자 한다면, **기존 테이블 이름**과 **새로운 테이블 이름**을 동일하게 유지하면 된다.
### 열 추가하기
* 테이블에 열을 추가하기 위해 아래 쿼리를 실행한다
>```sql
>ALTER TABLE `스키마`.`테이블` ADD COLUMN [열 구조];
>```
>* 별도의 명시가 없다면 열은 테이블의 가장 마지막에 추가된다
>* 추가하려는 열을 특정 열의 뒤에 추가하려면 아래와 같이 AFTER 키워드를 활용한다
>```SQL
>ALTER TABLE `스키마`.`테이블` ADD COLUMN [열 구조] AFTER `기준 열`;
>```
>* 어떠한 열을 기준으로 앞 자리에 열을 추가하는 키워드는 존재하지 않는다
>* 열을 테이블의 가장 앞자리에 추가하고자 할때에는 FIRST 키워드를 활용해야한다
>```SQL
>ALTER TABLE `스키마`.`테이블` ADD COLUMN [열 구조] FIRST;
>```
### 열 이름 변경하기
* 열의 이름을 변경하기 위해 아래 쿼리를 실행한다
```sql
ALTER TABLE `스키마`.`테이블` RENAME COLUMN `기존 열 이름` TO `새로운 이름`;
```
### 열 구조 수정하기
* 열의 구조를 수정하기 위해 아래 쿼리를 실행한다
>```SQL
>ALTER TABLE `스키마`.`테이블` MODIFY COLUMN `대상 열 이름` [이름을 제외한 열 구조];
>```
>* 열 구조 수정과 동시에 AFTER 및 FIRST 키워드를 사용하여 위치 또한 변경할 수 있다
### 열 삭제하기
* 열을 삭제하기 위해 아래 쿼리를 실행한다
* 열을 삭제하면 이에 해당하는 **레코드들의 데이터가 삭제되고 되돌릴 수 없음**으로 유의한다
```SQL
ALTER TABLE `스키마`.`테이블` DROP COLUMN `열 이름`;
```
## 삭제하기
* 테이블을 삭제하기 위해 아래 쿼리를 실행한다
* 테이블을 삭제하면 해당 테이블이 가지고 있는 ***레코드가 모두 삭제되고 되돌릴 수 없음***으로 유의한다
```SQL
DROP TABLE `스키마`.`테이블`;
```
# 열
* 열(Column)은 테이블에 존재하는 레코드가 가지는 데이터의 타입을 정하기 위해 사용한다
* 명명법 : 스네이크 케이스(~_~), 단/복수형
* 열의 구조는 아래와 같다
>```sql 
>`열이름` [데이터 타입] [NULL | NOT NULL]? [DEFAULT x]? [AUTO_INCREMENT]?
>```
>* NULL : 해당 열의 값이 비어있을 수 있다는 의미이다. 생략시 기본값
>* NOT NULL : 해당 열의 값이 비어있을 수 없다는 의미이다
>* DEFAULT x : 레코드 삽입시 해당 열의 값을 **`명시하지 않을 경우 사용할 기본 값을 x`** 로 한다. ***생략시엔 기본값은 NULL***이다
>* AUTO_INCREMENT : 정의된 필드에 대한 테이블에 레코드가 삽입될 때마다 자동으로 순차적 숫자 값을 생성한다 (주로 기본키를 생성시 사용한다)
